@page "/"
@using System.Diagnostics
@using Chessy.Engine.Pieces
@using Chessy.Engine.Extensions
@using Microsoft.AspNetCore.Html
@using System.Text
@using Microsoft.AspNetCore.Components.QuickGrid
@using Chessy.Engine.Events

@inject IJSRuntime JS


<style>
     body {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(8, 72px);
      grid-template-rows: repeat(8, 72px);
      border: solid gray;
    }

    .square {
      width: 72px;
      height: 72px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 72px;
      cursor: pointer;
      opacity: 1.0;
      border: none;
      color: black;
      font-family: 'FreeSerif', serif;
    }

    .selected {
        background-color: rgb(108, 249, 108) !important;
    }

    .lastMove {
        background-color: yellow !important;
    }

    .legalTarget {
        background-color: rgb(105, 223, 105) !important; /* Modified color */
    }

    .check {
        background-color: lightcoral !important;
    }

    .checkmate {
        background-color: darkred !important;
    }

    .light {
        background-color: white;
        filter: brightness(95%);
    }

    .dark {
        background-color: white;
        filter: brightness(85%);
    }

    .moveList {
        font-family: 'FreeSerif', serif;
    }

    .container {
        margin: 32px;
    }

    .grid {
        height: 15rem;
        overflow-y: auto;
    }

    .grid ::deep table {
        min-width: 100%;
    }

    table {
        font-size: 20px;
    }



</style>

@{
    var legalTargets = Enumerable.Empty<(int file, int rank)>();
    if (currentMove is not null)
    {
        legalTargets = validMoves.Where(x =>
                x.From.file == currentMove.From.file
                && x.From.rank == currentMove.From.rank)
            .Select(x => x.To);
    }
}

<div class="board">
    @foreach (int file in Enumerable.Range(0, 8))
    {
        <div class="rank">
        @foreach (int rank in Enumerable.Range(0, 8).Reverse())
        {
            var lastMove = position.Moves.LastOrDefault();

            var square = position.Board.Squares[file, rank];
            var cssClass = ((rank + file) % 2 == 0) ? "dark" : "light";

            if ((rank == currentMove?.From.rank && file == currentMove?.From.file)
                || (lastMove?.From.rank == rank && lastMove?.From.file == file)
                || (lastMove?.To.rank == rank && lastMove?.To.file == file))
            {
                cssClass += " selected";
            }

            if ((lastMove?.From.rank == rank && lastMove?.From.file == file)
                || (lastMove?.To.rank == rank && lastMove?.To.file == file))
            {
                cssClass += " lastMove";
            }

            if (legalTargets.Any(x => x.rank == rank && x.file == file))
                {
                    cssClass += " legalTarget";
                }


            if ((lastMove?.IsCheck ?? false) && square?.Kind == PieceKind.King && square.Color != lastMove.Piece.Color)
                {
                    cssClass += lastMove.IsCheckmate ? " checkmate" : " check";
                }

            <div class="square @cssClass" @onclick="@(() => OnCellClick(file, rank))">
                @(square?.Icon.ToUpper() ?? string.Empty)
            </div>
        }
        </div>
    }
</div>

<br />
<br />

<div class="container">
    <div>
        <FluentSelect
            Label="White:"
            Items="@PlayerOptions"
            TOption="Option<string>"
            OptionText="@(x => x.Text)"
            OptionValue="@(x => x.Value)"
            ValueChanged="OnWhitePlayerChange"
            Value="@selectedWhitePlayer">
        </FluentSelect>
    </div>
    <br>

    <div>
        <FluentSelect
            Label="Black:"
            Items="@PlayerOptions"
            TOption="Option<string>"
            OptionText="@(x => x.Text)"
            OptionValue="@(x => x.Value)"
            ValueChanged="OnBlackPlayerChange"
            Value="@selectedBlackPlayer">
        </FluentSelect>
    </div>

    <br>
    <div>
        <FluentProgress Value="@progressCurrent" Max="@progressTotal"></FluentProgress>
    </div>

    <br>

    <div class="grid">
        <QuickGrid Items="@MoveTable" Class="moveList">
            <Microsoft.AspNetCore.Components.QuickGrid.PropertyColumn Property="@(p => $"{p.Number}.")" Title="" />
            <Microsoft.AspNetCore.Components.QuickGrid.PropertyColumn Property="@(p => p.White)" />
            <Microsoft.AspNetCore.Components.QuickGrid.PropertyColumn Property="@(p => p.Black)" />
        </QuickGrid>
    </div>

    <br>
    <br>

    <FluentButton Appearance="Appearance.Accent" IconStart="@(new Icons.Regular.Size16.Copy())" OnClick="@CopyPgnToClipboard">Copy PGN</FluentButton>
</div>

@code {
    record MoveListItem(int Number, string White = "", string Black = "");

    List<MoveListItem> MoveList = new();

    IQueryable<MoveListItem> MoveTable => MoveList.AsQueryable();

    string PgnText
    {
        get
        {
            var asPgn = (string value) => value.Replace("♔", "K")
                .Replace("♕", "Q")
                .Replace("♖", "R")
                .Replace("♗", "B")
                .Replace("♘", "N");

            StringBuilder sb = new StringBuilder();
            foreach (var item in MoveTable)
            {
                sb.Append($"{item.Number}. {asPgn(item.White)} {asPgn(item.Black)} ");
            }

            return sb.ToString();
        }
    }

    string selectedWhitePlayer = "0";
    int whitePlayer => int.Parse(selectedWhitePlayer );

    string selectedBlackPlayer = "4";
    int blackPlayer => int.Parse(selectedBlackPlayer);

    Position position = new Position();

    IList<string> notation = new List<string>();

    string yourMove = string.Empty;

    string hint = string.Empty;

    Move? currentMove = null;

    IList<Move> validMoves = new List<Move>();

    int progressCurrent = 0;
    int progressTotal = 1;

    IEnumerable<Option<string>> PlayerOptions = new Option<string>[]
    {
        new() { Value = "0", Text = "Human" },
        new() { Value = "1", Text = "Comp level 1" },
        new() { Value = "2", Text = "Comp level 2" },
        new() { Value = "3", Text = "Comp level 3" },
        new() { Value = "4", Text = "Comp level 4" },
        new() { Value = "5", Text = "Comp level 5" },
        new() { Value = "6", Text = "Comp level 6" },
        new() { Value = "7", Text = "Comp level 7" },
    };

    protected override void OnInitialized()
    {
        base.OnInitialized();

        position.ResetToStartingPosition();
        MoveList.Clear();
        MoveList.Add(new MoveListItem(1, "..."));

        if (whitePlayer == 0)
        {
            validMoves = position.GetMoves(PieceColor.White, true, true).ToList();
        }
        else
        {
            ComputerMove(position.ColorToMove);
        }
    }

    async Task CopyPgnToClipboard()
    {
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", PgnText);
    }

    void OnCellClick(int file, int rank)
    {
        if (currentMove is null)
        {
            if (position.Board.Squares[file, rank]?.Color == position.ColorToMove)
            {
                currentMove = new Move
                {
                    From = (file, rank),
                };
            }
        }
        else
        {
            currentMove.To = (file, rank);

            var moveIndex = validMoves.ToList().FindIndex(x =>
                x.From.file == currentMove.From.file
                && x.From.rank == currentMove.From.rank
                && x.To.file == currentMove.To.file
                && x.To.rank == currentMove.To.rank);
            if (moveIndex >= 0)
            {
                MakeMove(moveIndex);
            }
            else
            {
                hint = "Error";
            }

            currentMove = null;
        }
    }

    void MakeMove(int moveIndex)
    {
        MakeMove(validMoves[moveIndex]);
    }

    void MakeMove(Move move)
    {
        var shortNotation = move.NotationVariants
            .First(x => validMoves.Count(y => y.NotationVariants.Contains(x)) == 1);
        Notate(move, shortNotation);

        var moves = position.Moves;
        moves.Add(move);
        position = Position.FromMoves(moves);
        validMoves.Clear();

        PassTurn();
    }

    void Notate(Move move, string notation)
    {
        if (move.Piece.Color == PieceColor.White)
        {
            MoveList[^1] = MoveList[^1] with { White = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                MoveList[^1] = MoveList[^1] with { Black = "..." };
            }
        }
        else
        {
            MoveList[^1] = MoveList[^1] with { Black = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                MoveList.Add(new MoveListItem(MoveList.Count + 1, "..."));
            }
        }
    }

    void ComputerMove(PieceColor playerColor)
    {
        Task.Run(() =>
        {
            var positionCopy = Position.FromMoves(position.Moves);
            validMoves = positionCopy.GetMoves(playerColor, true, true).ToList();

            void OnProgressChange(object? sender, FindMoveProgressEventArgs e)
            {
                progressCurrent = e.Current;
                progressTotal = e.Total;
                InvokeAsync(StateHasChanged);
            }
            positionCopy.FindMoveProgress += OnProgressChange;
            var aiLevel = playerColor == PieceColor.White ? whitePlayer : blackPlayer;
            var computerMove = positionCopy.FindBestMoveAB(playerColor, aiLevel);
            positionCopy.FindMoveProgress -= OnProgressChange;

            if (computerMove is not null)
            {
                var moves = positionCopy.Moves;
                moves.Add(computerMove);
                var shortNotation = computerMove.NotationVariants
                    .First(x => validMoves.Count(y => y.NotationVariants.Contains(x)) == 1);
                Notate(computerMove, shortNotation);

                position = Position.FromMoves(moves);
                InvokeAsync(StateHasChanged);
            }

            PassTurn();
        });
    }

    void PassTurn()
    {
        var lastMove = position.Moves.LastOrDefault();

        if (position.Moves.Count > 1000)
        {
            Console.WriteLine("Enough, stop.");
            Console.WriteLine("Game over");
            return;
        }

        if (lastMove?.IsCheckmate == true || lastMove?.IsStalemate == true)
        {
            Console.WriteLine(lastMove.IsCheckmate ? "Checkmate" : "Stalemate");
            Console.WriteLine("Game over");
            return;
        }

        var currentPlayer = position.ColorToMove == PieceColor.White ? whitePlayer : blackPlayer;
        if (currentPlayer == 0)
        {
            var positionCopy = Position.FromMoves(position.Moves);
            var sw = Stopwatch.StartNew();
            validMoves = positionCopy.GetMoves(position.ColorToMove, true, true).ToList();
            sw.Stop();
            Console.WriteLine($"Valid moves: {validMoves.Count} in {sw.ElapsedMilliseconds} ms");
        }
        else
        {
            ComputerMove(position.ColorToMove);
        }
    }

    private void OnWhitePlayerChange(string value)
    {
        selectedWhitePlayer = value;

        if (whitePlayer != 0 && position.ColorToMove == PieceColor.White)
        {
            ComputerMove(PieceColor.White);
        }
    }

    private void OnBlackPlayerChange(string value)
    {
        selectedBlackPlayer = value;

        if (blackPlayer != 0 && position.ColorToMove == PieceColor.Black)
        {
            ComputerMove(PieceColor.Black);
        }
    }
}
