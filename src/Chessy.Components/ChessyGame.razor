@using System.Diagnostics
@using System.Text
@using Chessy.Infractructure

@inject IJSRuntime _js
@inject IDialogService _dialogService
@inject IToastService _toastService
@inject GameBroker _gameBroker

<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: darkgray;
        margin: 0;
    }

    @@font-face {
        font-family: 'FreeSerif';
        src: url('FreeSerif.woff') format('woff');
        /* Add other font formats if necessary (e.g., .ttf, .otf) */
        font-weight: normal;
        font-style: normal;
    }

  .container {
      margin: 32px;
      padding: 12px !important;
      width: auto;
  }

  .reversed {
      flex-direction: column-reverse !important;
  }
</style>

<FluentCard Class="container">
    <FluentStack
        HorizontalAlignment="HorizontalAlignment.Center"
        HorizontalGap="16">

        <BoardDisplay AlwaysPromoteToQueen="@alwaysPromoteToQueen"
            Board="@game.Board"
            Disabled="@isBoardInputDisabled"
            CurrentPlayer="@game.ColorToMove"
            Flip="@flipBoard"
            OnMakeMove="@OnMakeMoveAsync"
            LastMove="@game?.Moves?.LastOrDefault()"
            ValidMoves="@validMoves"
        />

        <FluentStack Orientation="Orientation.Vertical">
            <FluentStack Orientation="Orientation.Horizontal">
                <FluentButton
                    IconStart="@(new Icons.Regular.Size20.Chess())"
                    OnClick="OnNewGameClickAsync">New game</FluentButton>

                <FluentButton
                    IconStart="@(new Icons.Regular.Size16.ArrowRepeatAll())"
                    OnClick="@(() => { flipBoard = !flipBoard; })">Flip board</FluentButton>
            </FluentStack>

            <FluentSpacer />

            @{ var cssClass = flipBoard ? string.Empty : "reversed"; }

            @if (game is not null && !game.IsRemote)
            {
                <FluentStack Orientation="Orientation.Vertical" Class="@cssClass">
                    <div>
                        <FluentLabel Typo="Typography.Body">White:</FluentLabel>
                        <PlayerSelector Label=""
                            Player="game.WhitePlayer"
                            OnChange="OnWhitePlayerChangeAsync" />
                    </div>

                    <div>
                        <FluentLabel Typo="Typography.Body">Black:</FluentLabel>
                        <PlayerSelector Label=""
                            Player="game.BlackPlayer"
                            OnChange="OnBlackPlayerChangeAsync" />
                    </div>
                </FluentStack>
            }

            <FluentSpacer />

            <FluentCheckbox @bind-Value="@alwaysPromoteToQueen" Label="Auto promote to Queen" />

            <FluentDivider Style="width: 100%;" Orientation=Orientation.Horizontal Role="DividerRole.Separator"/>

            <div class="grid" @ref="moveListElement">
                <MoveListGrid Moves="@moveList" />
            </div>

            <FluentProgress
                Width="100%"
                Stroke="ProgressStroke.Normal"
                Value="@progressCurrent"
                Max="@progressTotal">
            </FluentProgress>

            <FluentButton
                IconStart="@(new Icons.Regular.Size16.Copy())"
                OnClick="@CopyPgnToClipboard"
                disabled="@(!moveList.Any())"
                >Copy PGN</FluentButton>
        </FluentStack>
    </FluentStack>
</FluentCard>

@code {
    [Parameter]
    public Player WhitePlayer { get; set; } = new() { Type = PlayerType.Human };

    [Parameter]
    public Player BlackPlayer { get; set; } = new() { Type = PlayerType.Computer };

    [Parameter]
    public Guid? GameKey { get; set; } = null;

    private List<MoveListItem> moveList = new();

    private bool isGameOver = false;

    private bool isCurrentPlayerHuman =>
        (game.ColorToMove == PieceColor.White && game.WhitePlayer.IsHuman)
        || (game.ColorToMove == PieceColor.Black && game.BlackPlayer.IsHuman);

    private bool isBoardInputDisabled => !isCurrentPlayerHuman || isGameOver;

    private bool isComputerThinking = false;

    private CancellationTokenSource? cts = null;

    private string PgnText
    {
        get
        {
            var sb = new StringBuilder();
            foreach (var item in moveList)
            {
                if (item.White is not null)
                {
                    sb.Append($"{item.Number}. {item.White} ");
                    if (item.Black is not null)
                    {
                        sb.Append($"{item.Black} ");
                    }
                }
            }

            return sb.ToString();
        }
    }

    private Game game = new();

    private IList<string> notation = new List<string>();

    private bool alwaysPromoteToQueen = true;

    private bool flipBoard = false;

    private IList<Move> validMoves = new List<Move>();

    private int progressCurrent = 0;

    private int progressTotal = 1;

    private ElementReference moveListElement { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await StartNewGameAsync();
    }

    private async Task CopyPgnToClipboard()
    {
        await _js.InvokeVoidAsync("copyTextToClipboard", PgnText);
        _toastService.ShowInfo("Copied");
    }

    private async Task OnMakeMoveAsync(Move move)
    {
        var shortNotation = game.GetShortNotation(move);
        await NotateAsync(move, shortNotation);

        @* var moves = game.Moves;
        moves.Add(move);
        game = Position.FromMoves(moves); *@
        game.MakeMove(move);
        game.Moves.Add(move); // TODO
        validMoves.Clear();

        if (game.IsRemote && GameKey.HasValue)
        {
            _gameBroker.RemoteMakeMove(GameKey.Value, move);
        }

        await PassTurnAsync();
    }

    private async Task NotateAsync(Move move, string notation)
    {
        if (move.Piece!.Color == PieceColor.White)
        {
            moveList[^1] = moveList[^1] with { White = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                moveList[^1] = moveList[^1] with { Black = null };
            }
        }
        else
        {
            moveList[^1] = moveList[^1] with { Black = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                moveList.Add(new MoveListItem(moveList.Count + 1));
            }
        }

        await ScrollMoveListAsync();
    }

    private async Task ComputerMoveAsync(PieceColor playerColor)
    {
        Console.WriteLine($"Computer move for {playerColor}");

            Console.WriteLine("Thinking task started...");
            progressTotal = 1;
            progressCurrent = 0;
            await InvokeAsync(StateHasChanged);
            await Task.Delay(1);

            async void OnProgressChange(object? sender, FindMoveProgressEventArgs e)
            {
                progressCurrent = e.Current;
                progressTotal = e.Total;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);
            }

            var gameCopy = Game.FromMoves(game.Moves);
            gameCopy.FindMoveProgress += OnProgressChange;

            var player = playerColor == PieceColor.White ? game.WhitePlayer : game.BlackPlayer;
            Trace.Assert(player.IsComputer);
            Trace.Assert(player.ComputerLevel.HasValue);
            int aiLevel = player.ComputerLevel.Value;

            Move? move = null;
            cts = new CancellationTokenSource();
            try
            {
                isComputerThinking = true;
                move = await gameCopy.FindBestMoveABAsync(playerColor, aiLevel, cts.Token);
            }
            catch (OperationCanceledException)
            {
                progressCurrent = 0;
                await InvokeAsync(StateHasChanged);
                return;
            }
            finally
            {
                cts?.Dispose();
                cts = null;
                isComputerThinking = false;
            }

            gameCopy.FindMoveProgress -= OnProgressChange;

            if (move is not null)
            {
                progressCurrent = progressTotal;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);

                IEnumerable<Move> validMoves = gameCopy.GetMoves(playerColor).ToList();

                var shortNotation = game.GetShortNotation(move);
                await NotateAsync(move, shortNotation);

                game.MakeMove(move);
                game.Moves.Add(move);

                progressCurrent = 0;
            }

            await PassTurnAsync();
    }

    private async Task PassTurnAsync()
    {
        await InvokeAsync(StateHasChanged);

        var lastMove = game.Moves.LastOrDefault();
        Console.WriteLine($"Last move: {lastMove}");
        if (lastMove is null) { return; }

        if (game.Moves.Count > 1000)
        {
            await _dialogService.ShowInfoAsync("This goes for too long, the game abandoned.", "Draw");
            isGameOver = true;
            return;
        }

        game.ColorToMove = game.ColorToMove.OpponentColor();
        var currentPlayer = game.ColorToMove == PieceColor.White ? game.WhitePlayer : game.BlackPlayer;
        Console.WriteLine(game.ColorToMove);
        Console.WriteLine(currentPlayer.Type);

        var sw = Stopwatch.StartNew();
        var moves = game.GetMoves(game.ColorToMove).ToList();
        sw.Stop();
        if (!moves.Any())
        {
            if (lastMove.IsCheck)
            {
                var winner = lastMove.Piece.Color.ToString();

                _toastService.ShowInfo($"Checkmate - {winner} won.");
                isGameOver = true;
                return;
            }

            _toastService.ShowInfo("Stalemate - draw.");
            isGameOver = true;
            return;
        }

        validMoves = currentPlayer.IsHuman ? moves : [];

        if (currentPlayer.IsComputer)
        {
            await ComputerMoveAsync(game.ColorToMove);
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task OnWhitePlayerChangeAsync(Player value)
    {
        await InterruptComputerThinkingAsync();
        game.WhitePlayer = value;

        if (game.WhitePlayer.IsComputer && game.ColorToMove == PieceColor.White)
        {
            await ComputerMoveAsync(PieceColor.White);
        }
    }

    private async Task OnBlackPlayerChangeAsync(Player value)
    {
        await InterruptComputerThinkingAsync();
        game.BlackPlayer = value;

        if (game.BlackPlayer.IsComputer && game.ColorToMove == PieceColor.Black)
        {
            await ComputerMoveAsync(PieceColor.Black);
        }
    }

    public async Task ScrollMoveListAsync()
    {
        await _js.InvokeVoidAsync("scrollElementToBottom", moveListElement);
    }

    public async Task StartNewGameAsync()
    {
        await InterruptComputerThinkingAsync();

        if (GameKey.HasValue)
        {
            var remoteGame = _gameBroker.GetGame(GameKey.Value);
            if (remoteGame is null)
            {
                throw new InvalidDataException("Game does not exist");
            }

            game = remoteGame;
            if (game.WhitePlayer.IsRemoteGuest)
            {
                Trace.Assert(game.BlackPlayer.IsHuman);
                _gameBroker.OnRemoveMakeMove[GameKey.Value] = OnRemoteMakeMoveAsync;
                flipBoard = true;
            }
            else if (game.BlackPlayer.IsRemoteGuest)
            {
                Trace.Assert(game.WhitePlayer.IsHuman);
                _gameBroker.OnRemoveMakeMove[GameKey.Value] = OnRemoteMakeMoveAsync;
            }
            else
            {
                throw new InvalidOperationException("This is wrong");
            }
        }
        else
        {
            game.ResetToStartingPosition();
            game.WhitePlayer = WhitePlayer;
            game.BlackPlayer = BlackPlayer;
        }

        moveList.Clear();
        isGameOver = false;
        moveList.Add(new MoveListItem(1));

        switch (game.WhitePlayer.Type)
        {
            case PlayerType.Human:
            case PlayerType.RemoteGuest:
                validMoves = game.GetMoves(PieceColor.White).ToList();
                break;

            case PlayerType.Computer:
                await ComputerMoveAsync(game.ColorToMove);
                break;
        }
    }

    public async Task OnNewGameClickAsync()
    {
        await StartNewGameAsync();
    }

    private async Task OnRemoteMakeMoveAsync(Move remoteMove)
    {
        Console.WriteLine($"Recv: key {GameKey}: {remoteMove}");

        var moves = game.GetMoves(game.ColorToMove);
        var move = moves.Single(x =>
            x.From == remoteMove.From
            && x.To == remoteMove.To
            && x.PromotionPieceKind == remoteMove.PromotionPieceKind);
        Console.WriteLine($"FOUND {move}");

        var shortNotation = game.GetShortNotation(move);
        await NotateAsync(move, shortNotation);

        game.MakeMove(move);
        game.Moves.Add(move);

        await PassTurnAsync();
    }

    private async Task InterruptComputerThinkingAsync()
    {
        if (!isComputerThinking) { return; }

        Trace.Assert(cts is not null);
        cts?.Cancel();

        int steps = 10;
        while (isComputerThinking)
        {
            steps--;
            if (steps < 0)
            {
                throw new Exception("Timeout while waiting computer thinking interruption");
            }

            await Task.Delay(50);
        }
    }
}
