@using System.Diagnostics
@using System.Text

@inject IJSRuntime _js
@inject IDialogService _dialogService
@inject IToastService _toastService

<style>
    body {
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: darkgray;
        margin: 0;
    }

    @@font-face {
        font-family: 'FreeSerif';
        src: url('FreeSerif.woff') format('woff');
        /* Add other font formats if necessary (e.g., .ttf, .otf) */
        font-weight: normal;
        font-style: normal;
    }

  .container {
      margin: 32px;
      padding: 12px !important;
      width: auto;
  }

  .reversed {
      flex-direction: column-reverse !important;
  }
</style>

<FluentCard Class="container">
    <FluentStack
        HorizontalAlignment="HorizontalAlignment.Center"
        HorizontalGap="16">

        <BoardDisplay AlwaysPromoteToQueen="@alwaysPromoteToQueen"
            Board="@position.Board"
            Disabled="@isBoardInputDisabled"
            CurrentPlayer="@position.ColorToMove"
            Flip="@flipBoard"
            OnMakeMove="@OnMakeMoveAsync"
            LastMove="@position?.Moves?.LastOrDefault()"
            ValidMoves="@validMoves"
        />

        <FluentStack Orientation="Orientation.Vertical">
            <FluentStack Orientation="Orientation.Horizontal">
                <FluentButton
                    IconStart="@(new Icons.Regular.Size20.Chess())"
                    OnClick="OnNewGameClickAsync">New game</FluentButton>

                <FluentButton
                    IconStart="@(new Icons.Regular.Size16.ArrowRepeatAll())"
                    OnClick="@(() => { flipBoard = !flipBoard; })">Flip board</FluentButton>
            </FluentStack>

            <FluentSpacer />

            @{ var cssClass = flipBoard ? string.Empty : "reversed"; }

            <FluentStack Orientation="Orientation.Vertical" Class="@cssClass">
                <div>
                    <FluentSelect
                        Label="White:"
                        Items="@PlayerOptions"
                        TOption="Option<string>"
                        OptionText="@(x => x.Text)"
                        OptionValue="@(x => x.Value)"
                        ValueChanged="OnWhitePlayerChangeAsync"
                        Value="@WhitePlayer">
                    </FluentSelect>
                </div>

                <div>
                    <FluentSelect
                        Label="Black:"
                        Items="@PlayerOptions"
                        TOption="Option<string>"
                        OptionText="@(x => x.Text)"
                        OptionValue="@(x => x.Value)"
                        ValueChanged="OnBlackPlayerChangeAsync"
                        Value="@BlackPlayer">
                    </FluentSelect>
                </div>
            </FluentStack>

            <FluentSpacer />

            <FluentCheckbox @bind-Value="@alwaysPromoteToQueen" Label="Auto promote to Queen" />

            <FluentDivider Style="width: 100%;" Orientation=Orientation.Horizontal Role="DividerRole.Separator"/>

            <div class="grid" @ref="moveListElement">
                <MoveListGrid Moves="@moveList" />
            </div>

            <FluentProgress
                Width="100%"
                Stroke="ProgressStroke.Normal"
                Value="@progressCurrent"
                Max="@progressTotal">
            </FluentProgress>

            <FluentButton
                IconStart="@(new Icons.Regular.Size16.Copy())"
                OnClick="@CopyPgnToClipboard"
                disabled="@(!moveList.Any())"
                >Copy PGN</FluentButton>
        </FluentStack>
    </FluentStack>
</FluentCard>

@code {
    [Parameter]
    public string WhitePlayer { get; set; } = "0";
    int whitePlayer => int.Parse(WhitePlayer);

    [Parameter]
    public string BlackPlayer { get; set; }= "5";
    int blackPlayer => int.Parse(BlackPlayer);

    List<MoveListItem> moveList = new();

    bool isGameOver = false;

    bool isCurrentPlayerHuman =>
        (position.ColorToMove == PieceColor.White && whitePlayer == 0)
        || (position.ColorToMove == PieceColor.Black && blackPlayer == 0);

    bool isBoardInputDisabled => !isCurrentPlayerHuman || isGameOver;

    bool isComputerThinking = false;

    CancellationTokenSource? cts = null;

    string PgnText
    {
        get
        {
            var sb = new StringBuilder();
            foreach (var item in moveList)
            {
                if (item.White is not null)
                {
                    sb.Append($"{item.Number}. {item.White} ");
                    if (item.Black is not null)
                    {
                        sb.Append($"{item.Black} ");
                    }
                }
            }

            return sb.ToString();
        }
    }

    Position position = new();

    IList<string> notation = new List<string>();

    bool alwaysPromoteToQueen = true;

    bool flipBoard = false;

    IList<Move> validMoves = new List<Move>();

    int progressCurrent = 0;
    int progressTotal = 1;

    IEnumerable<Option<string>> PlayerOptions = new Option<string>[]
    {
        new() { Value = "0", Text = "Human" },
        new() { Value = "1", Text = "Comp level 1" },
        new() { Value = "2", Text = "Comp level 2" },
        new() { Value = "3", Text = "Comp level 3" },
        new() { Value = "4", Text = "Comp level 4" },
        new() { Value = "5", Text = "Comp level 5" },
        new() { Value = "6", Text = "Comp level 6" },
        new() { Value = "7", Text = "Comp level 7" },
    };

    private ElementReference moveListElement { get; set; } = new();

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        await StartNewGameAsync();
    }

    private async Task CopyPgnToClipboard()
    {
        await _js.InvokeVoidAsync("copyTextToClipboard", PgnText);
        _toastService.ShowInfo("Copied");
    }

    private async Task OnMakeMoveAsync(Move move)
    {
        var shortNotation = move.GetNotationVariants()
            .First(x => validMoves.Count(y => y.GetNotationVariants().Contains(x)) == 1);
        await NotateAsync(move, shortNotation);

        var moves = position.Moves;
        moves.Add(move);
        position = Position.FromMoves(moves);
        validMoves.Clear();

        await PassTurnAsync();
    }

    private async Task NotateAsync(Move move, string notation, bool isLetter = true)
    {
        if (isLetter)
        {
            notation = notation
                .Replace("♔", "K")
                .Replace("♕", "Q")
                .Replace("♖", "R")
                .Replace("♗", "B")
                .Replace("♘", "N");
        }

        if (move.Piece!.Color == PieceColor.White)
        {
            moveList[^1] = moveList[^1] with { White = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                moveList[^1] = moveList[^1] with { Black = null };
            }
        }
        else
        {
            moveList[^1] = moveList[^1] with { Black = notation };
            if (!(move.IsCheckmate || move.IsStalemate))
            {
                moveList.Add(new MoveListItem(moveList.Count + 1));
            }
        }

        await ScrollMoveListAsync();
    }

    private async Task ComputerMoveAsync(PieceColor playerColor)
    {
        Console.WriteLine($"Computer move for {playerColor}");

            Console.WriteLine("Thinking task started...");
            Position positionCopy = Position.FromMoves(position.Moves);
            progressTotal = 1;
            progressCurrent = 0;
            await InvokeAsync(StateHasChanged);
            await Task.Delay(1);

            async void OnProgressChange(object? sender, FindMoveProgressEventArgs e)
            {
                progressCurrent = e.Current;
                progressTotal = e.Total;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);
            }

            positionCopy.FindMoveProgress += OnProgressChange;
            int aiLevel = playerColor == PieceColor.White ? whitePlayer : blackPlayer;

            Move? computerMove = null;
            cts = new CancellationTokenSource();
            try
            {
                isComputerThinking = true;
                computerMove = await positionCopy.FindBestMoveABAsync(playerColor, aiLevel, cts.Token);
            }
            catch (OperationCanceledException)
            {
                progressCurrent = 0;
                await InvokeAsync(StateHasChanged);
                return;
            }
            finally
            {
                cts?.Dispose();
                cts = null;
                isComputerThinking = false;
            }

            positionCopy.FindMoveProgress -= OnProgressChange;

            if (computerMove is not null)
            {
                Console.WriteLine("Computer move found: " + computerMove.GetNotationVariants().First());
                progressCurrent = progressTotal;
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);

                IEnumerable<Move> validMoves = positionCopy.GetMoves(playerColor).ToList();

                var moves = positionCopy.Moves;
                moves.Add(computerMove);

                var shortNotation = computerMove.GetNotationVariants()
                    .First(x => validMoves.Count(y => y.GetNotationVariants().Contains(x)) == 1);

                await NotateAsync(computerMove, shortNotation);

                position = Position.FromMoves(moves);

                progressCurrent = 0;
            }

            await PassTurnAsync();
    }

    private async Task PassTurnAsync()
    {
        await InvokeAsync(StateHasChanged);
        await Task.Delay(1);

        var lastMove = position.Moves.LastOrDefault();
        if (lastMove is null) { return; }

        if (position.Moves.Count > 1000)
        {
            await _dialogService.ShowInfoAsync("This goes for too long, the game abandoned.", "Draw");
            isGameOver = true;
            return;
        }

        var currentPlayer = position.ColorToMove == PieceColor.White ? whitePlayer : blackPlayer;

        var sw = Stopwatch.StartNew();
        var positionCopy = Position.FromMoves(position.Moves);
        validMoves = positionCopy.GetMoves(position.ColorToMove).ToList();
        if (!validMoves.Any())
        {
            if (lastMove.IsCheck)
            {
                var winner = lastMove.Piece.Color.ToString();

                _toastService.ShowEvent($"Checkmate - {winner} won.");
                isGameOver = true;
                return;
            }

            _toastService.ShowEvent("Stalemate - draw.");
            isGameOver = true;
            return;
        }

        sw.Stop();

        if (currentPlayer != 0)
        {
            await ComputerMoveAsync(position.ColorToMove);
        }
    }

    private async Task OnWhitePlayerChangeAsync(string value)
    {
        await InterruptComputerThinkingAsync();
        WhitePlayer = value;

        if (whitePlayer != 0 && position.ColorToMove == PieceColor.White)
        {
            await ComputerMoveAsync(PieceColor.White);
        }
    }

    private async Task OnBlackPlayerChangeAsync(string value)
    {
        await InterruptComputerThinkingAsync();
        BlackPlayer = value;

        if (blackPlayer != 0 && position.ColorToMove == PieceColor.Black)
        {
            await ComputerMoveAsync(PieceColor.Black);
        }
    }

    public async Task ScrollMoveListAsync()
    {
        await _js.InvokeVoidAsync("scrollElementToBottom", moveListElement);
    }

    public async Task StartNewGameAsync()
    {
        await InterruptComputerThinkingAsync();
        position.ResetToStartingPosition();
        moveList.Clear();
        isGameOver = false;
        moveList.Add(new MoveListItem(1));

        if (whitePlayer == 0)
        {
            validMoves = position.GetMoves(PieceColor.White).ToList();
        }
        else
        {
            await ComputerMoveAsync(position.ColorToMove);
        }
    }

    public async Task OnNewGameClickAsync()
    {
        await StartNewGameAsync();
    }

    private async Task InterruptComputerThinkingAsync()
    {
        if (!isComputerThinking) { return; }

        Trace.Assert(cts is not null);
        cts?.Cancel();

        int steps = 10;
        while (isComputerThinking)
        {
            steps--;
            if (steps < 0)
            {
                throw new Exception("Timeout while waiting computer thinking interruption");
            }

            await Task.Delay(50);
        }
    }
}
